<!DOCTYPE html>
<meta charset="utf-8">
<style>
line {
    stroke: #444;
    stroke-width: 5px;
}
</style>
<canvas width="960" height="600">
</canvas>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://measure-fps.surge.sh/measureFPS.js"></script>

<script>
var data = [];
var stepSize = 100;
var framesPerNumberNodes = {};

var logFps = (fps) => {
    if(!framesPerNumberNodes[data.length]) {
        framesPerNumberNodes[data.length] = [];
    }
    framesPerNumberNodes[data.length].push(fps)
};
function printMedianFps() {
    const medians = {};
    for(const numberOfNodes in framesPerNumberNodes) {
        const medianFps = median(framesPerNumberNodes[numberOfNodes]);
        //console.log(numberOfNodes, medianFps)
        medians[numberOfNodes] = medianFps;
    }
    let csvContent = '';
    csvContent += Object.keys(medians).join(',');
    csvContent += '\r\n';
    csvContent += Object.values(medians).join(',');
    console.log(csvContent);
}

var canvas = document.getElementsByTagName('canvas')[0];
var ctx = canvas.getContext('2d');

function getCircle(cx, cy, r) {
  return {
    getPointFromAngle: function(angle) {
      return {
        x: cx + Math.sin(angle) * r,
        y: cy - Math.cos(angle) * r
      }
    }
  };
}


var progressLineData = {angle: 0, innerCircle: getCircle(300, 300, 100), outerCircle: getCircle(300, 300, 100 + 200)};
var maxAngularSpeed = 0.005 + 0.03;

for(var i = 0; i < stepSize; i++) {
  addRandomData()
}

setInterval(() => {
    if(data.length > 30000)
        return;

    for(var i = 0; i < stepSize; i++) {
        addRandomData();
    }

    //console.log(framesPerNumberNodes);
}, 6000);

function addRandomData() {
    const circle = getCircle(300, 300, 100 + Math.random() * 200);
    const angle = Math.random() * 2 * Math.PI;
    data.push({
        color: 'rgb(100,100,100)',
        circle: circle,
        angle: angle,
        angularSpeed: 0.005 + Math.random() * 0.03,
        position: circle.getPointFromAngle(angle),
        id: getRandomString(6)
    });
}

var updates = 0;
function updatePositions() {
  updates++;
  data.forEach(function(data, i) {
    var angle = data.angle;
    const circle = data.circle;
    //if(updates > i) {
      angle += data.angularSpeed;
    //}
    data.angle = angle;
    data.position = circle.getPointFromAngle(angle);
  });
  progressLineData.angle += maxAngularSpeed;
}

function updateVis() {
  ctx.clearRect(0, 0, 960, 600);

  for(const rect of data) {
      ctx.fillStyle = rect.color;
      ctx.fillRect(rect.position.x, rect.position.y, 5, 5);
  }

}

const raf = function() {
  updatePositions();
  updateVis();

  requestAnimationFrame(raf);
};
raf();


const lastTenFramesTimes2 = [];
const isCanvas2 = false;//document.getElementsByTagName("canvas").length;

const performanceMeasureRAF2 = () => {

    if(!isCanvas2) {
        lastTenFramesTimes2.push(Date.now());

        if(lastTenFramesTimes2.length > 100) {
            lastTenFramesTimes2.shift(); // Remove first item
        }

        if(lastTenFramesTimes2.length > 1) {
            const timeForTenDrawsMs = Date.now() - lastTenFramesTimes2[0];
            const fps = Math.round(lastTenFramesTimes2.length / timeForTenDrawsMs * 1000);
            document.getElementById('fps-meter').children[1].children[0].innerText = fps;
            logFps(fps);
        }
    }


    requestAnimationFrame(performanceMeasureRAF2);
};

performanceMeasureRAF2();

function getRandomString(length) {
    var alphabet = 'abcdefghijklmnopqrstuvwxyz';
    var string = '';

    for(var i = 0; i < length; i++)
    {
        string += alphabet[Math.round(Math.random() * (alphabet.length - 1))];
    }
    return string;
}

function median(arr) {
    arr.sort(function(a, b) {
        return a - b;
    });
    var mid = arr.length / 2;
    return mid % 1 ? arr[mid - 0.5] : (arr[mid - 1] + arr[mid]) / 2;
}

</script>
