<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .links line.main {
        stroke: #777;
    }
    .links line.secondary {
        stroke-opacity: 0;
    }

</style>
<svg width="960" height="600"></svg>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://measure-fps.surge.sh/measureFPS.js"></script>

<script>
    fpsLog = []    

    const lastTenFramesTimes2 = [];
    const isCanvas2 = document.getElementsByTagName("canvas").length;

    const performanceMeasureRAF2 = () => {

        if(!isCanvas2) {
            lastTenFramesTimes2.push(Date.now());

            if(lastTenFramesTimes2.length > 100) {
                lastTenFramesTimes2.shift(); // Remove first item
            }

            if(lastTenFramesTimes2.length > 1) {
                const timeForTenDrawsMs = Date.now() - lastTenFramesTimes2[0];
                const fps = Math.round(lastTenFramesTimes2.length / timeForTenDrawsMs * 1000);
                fpsLog.push(fps);
              
            }
        }


        requestAnimationFrame(performanceMeasureRAF2);
    };

performanceMeasureRAF2();

    const mainNodesRepelForce = (function() {
        const force = (alpha) => {
            if(force.savedNodes && force.savedNodes.length) {
                for(let i = 0; i < force.savedNodes.length && i < force.interactionBetweenFirst; i++) {
                    for(let j = i + i; j < force.savedNodes.length && j < force.interactionBetweenFirst; j++) {
                        const difference = {
                            x: force.savedNodes[i].x - force.savedNodes[j].x,
                            y: force.savedNodes[i].y - force.savedNodes[j].y
                        };

                        force.savedNodes[i].x += difference.x * alpha * force.currentStrength;
                        force.savedNodes[i].y += difference.y * alpha * force.currentStrength;
                        force.savedNodes[j].x -= difference.x * alpha * force.currentStrength;
                        force.savedNodes[j].y -= difference.y * alpha * force.currentStrength;
                    }
                }
            }
        };

        force.savedNodes = [];
        force.currentStrength = 1;
        force.interactionBetweenFirst = 2;

        force.initialize = (nodes) => {
            if(!nodes || !nodes.length) {
                return;
            }
            force.savedNodes = nodes;
        };

        force.strength = (strength) => {
            force.currentStrength = strength;
            return force;
        };

        force.interactionBetweenFirst = (numberMainNodes) => {
            force.numberMainNodes = numberMainNodes;
            return force;
        };

        return force;
    });

    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    var color = d3.scaleOrdinal(d3.schemeCategory20);
    var numberOfMainNodes = 8;

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink()
            .id(function(d) { return d.id; })
            .distance(d => 30 / d.value))
        .force("charge", mainNodesRepelForce().interactionBetweenFirst(numberOfMainNodes).strength(50))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(2))
        .alphaDecay(0.005);

    function createRandomNoiseGraph(numberNodes, numberMainNodes)
    {
        var alphabet = 'abcdefghijklmnopqrstuvwxyz';
        var ids = [];

        for(var i = 0; i < numberNodes; i++)
        {
            var id = '';
            for(let j = 0; j < 10; j++) {
                id += alphabet[Math.round(Math.random() * (alphabet.length - 1))];
            }
            ids.push(id);
        }

        var nodes = [];
        var links = [];

        for(i = 0; i < numberMainNodes; i++)
        {
            nodes.push({id: ids[i], group: i, type: 'main'});
        }

        for(i = 0; i < 1; i++)
        {
            for(let j = i + 1; j < numberMainNodes; j++) {
                links.push({source: ids[i], target: ids[j], fromId: ids[i], toId: ids[j], type: 'main', value: 1000});
            }
        }

        const nearbyNodesPerMainNode = Math.round((numberNodes - numberMainNodes) / numberMainNodes);
        for(i = 0; i < numberMainNodes; i++)
        {
            let mainNode = nodes[i];
            for(let j = 0; j < nearbyNodesPerMainNode; j++) {
                const totalIndex = numberMainNodes + i * (nearbyNodesPerMainNode) + j;
                nodes.push({id: ids[totalIndex], group: mainNode.group, type: 'secondary'});
                links.push({source: ids[i], target: ids[totalIndex], fromId: ids[i], toId: ids[totalIndex],
                    type: 'secondary', value: Math.random() * 30});
            }
        }

        return { nodes: nodes, links: links };
    }

    var graph = createRandomNoiseGraph(3000, numberOfMainNodes);
    setTimeout(function(error) {
//d3.json("miserables.json", function(error, graph) {
//d3.json("yeast.json", function(error, graph) {
        if (error) throw error;

        var link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("stroke-width", 2)
            .attr('class', d => d.type);

        var node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("rect")
            .data(graph.nodes)
            .enter().append("rect")
            .attr("width", 2)
            .attr("height", 2)
            .attr("fill", function(d) { return color(d.group); })
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        lastFiveTicks = [];
            start = console.time("Timer")
            logged = false;
            tick = 0;
        
        function ticked() {
            
            tick+=1
                
            let totalDist = 0;
            let totalPositionValue = 0;
            svg.select('.nodes').selectAll('rect').each(function(d) {
                totalDist += Math.sqrt(Math.pow(Math.round(d.x) - Math.round(d3.select(this).attr('x')), 2) + Math.pow(Math.round(d.y) - Math.round(d3.select(this).attr('y')), 2))
                totalPositionValue += Math.sqrt(Math.pow(d.x,2) + Math.pow(d.y, 2));
            })
            lastFiveTicks.push(totalDist/totalPositionValue);

            if(lastFiveTicks.length > 5){
                lastFiveTicks.shift();
            }
                
            
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y; });
            
            sum = 0;
            for (i=0;i < lastFiveTicks.length; i++){
                sum += lastFiveTicks[i];
            }


            avg = sum/lastFiveTicks.length;
            //console.log(tick);

            if (tick != 1 && logged==false && avg <= 0.002){
                console.log(tick, avg);
                end = console.timeEnd("Timer");
                logged = true
                 fpsAvg = 0;
            
                //skip the first 5 logs to leave out intialization fps
                for (i=0; i <5; i++){
                fpsLog.shift();
            
                }
                for (i=0;i<fpsLog.length;i++){
                    fpsAvg += fpsLog[i];

                }
               
                console.log('fps log',fpsLog);
                console.log('fps avg', fpsAvg/fpsLog.length);
            

            }
        }
    });

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

</script>
