<!DOCTYPE html>
<meta charset="utf-8">
<style>
line {
    stroke: #444;
    stroke-width: 5px;
}
</style>
<svg width="960" height="600">
    <g id="rectsG"></g>
    <line></line>
    <text text-anchor="middle" font-size="70" id="indicator"></text>
    <text text-anchor="middle" font-size="35" id="turns">Turns</text>
</svg>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://measure-fps.surge.sh/measureFPS.js"></script>
<script src="ssvg.js"></script>

<script>
fpsLog = []    
frontLog = []
    

new SSVG({
    getFps: function(fps) {
        const fpsElement = document.getElementById("fps-element");
        fpsElement.innerHTML = fps;
        //console.log(fps);
        fpsLog.push(fps);
    }
});


const lastTenFramesTimes2 = [];
    const isCanvas2 = document.getElementsByTagName("canvas").length;

    const performanceMeasureRAF2 = () => {

        if(isCanvas2) {
            lastTenFramesTimes2.push(Date.now());

            if(lastTenFramesTimes2.length > 100) {
                lastTenFramesTimes2.shift(); // Remove first item
            }

            if(lastTenFramesTimes2.length > 1) {
                const timeForTenDrawsMs = Date.now() - lastTenFramesTimes2[0];
                const fps = Math.round(lastTenFramesTimes2.length / timeForTenDrawsMs * 1000);
                //fpsLog.push(fps);
                frontLog.push(fps);
            }
        }


        requestAnimationFrame(performanceMeasureRAF2);
    };

performanceMeasureRAF2();
    
setTimeout(
    function(){ 
        fpsAvg = 0;
        frontAvg = 0;
        for (i=0; i <100; i++){
            fpsLog.shift();
            frontLog.shift();
        }
        for (i=0; i<fpsLog.length; i++){
            fpsAvg += fpsLog[i];
        }
        for (i=0; i<frontLog.length; i++){
            frontAvg += frontLog[i];
        }
        console.log('FPS Log', fpsLog);
        console.log('FPS Avg', fpsAvg/fpsLog.length)
        console.log('Front Log', frontLog);
        console.log('Front Avg', frontAvg/frontLog.length)
    
    }, 60000);

var svg = d3.select("svg");
var rectsG = svg.select('#rectsG');

d3.select('#indicator').attr('x', 300).attr('y', 325);
d3.select('#turns').attr('x', 300).attr('y', 365);

var color = d3.scaleOrdinal(d3.schemeAccent);

function getCircle(cx, cy, r) {
  return {
    getPointFromAngle: function(angle) {
      return {
        x: cx + Math.sin(angle) * r,
        y: cy - Math.cos(angle) * r
      }
    }
  };
}

var data = [];
var progressLineData = {angle: 0, innerCircle: getCircle(300, 300, 100), outerCircle: getCircle(300, 300, 100 + 200)};
var maxAngularSpeed = 0.005 + 0.03;
for(var i = 0; i < 5000; i++) {
  const circle = getCircle(300, 300, 100 + Math.random() * 200);
  const angle = Math.random() * 2 * Math.PI;
  data.push({
    color: color(i), //color(Math.floor(Math.random() * 20)),
    circle: circle,
    angle: 0,
    angularSpeed: 0.005 + Math.random() * 0.03,
    position: circle.getPointFromAngle(angle),
    id: i
  });
}

var updates = 0;
function updatePositions() {
  updates++;
  data.forEach(function(data, i) {
    var angle = data.angle;
    const circle = data.circle;
    if(updates > i) {
      angle += data.angularSpeed;
    }
    data.angle = angle;
    data.position = circle.getPointFromAngle(angle);
  });
  progressLineData.angle += maxAngularSpeed;
}

function updateVis() {
  var nodes = rectsG.selectAll('rect')
    .data(data, function(d) { return d.id });

  nodes.enter()
    .append('rect')
    .attr('width', 5)
    .attr('height', 5)
    .attr('fill', function(d) { return d.color });

  nodes
    .attr('x', function(d) {return d.position.x })
    .attr('y', function(d) {return d.position.y });

  svg.select('line')
      .attr('x1', function() { return progressLineData.innerCircle.getPointFromAngle(progressLineData.angle).x })
      .attr('y1', function() { return progressLineData.innerCircle.getPointFromAngle(progressLineData.angle).y })
      .attr('x2', function() { return progressLineData.outerCircle.getPointFromAngle(progressLineData.angle).x })
      .attr('y2', function() { return progressLineData.outerCircle.getPointFromAngle(progressLineData.angle).y });

  svg.select('#indicator')
      .text(Math.floor(progressLineData.angle / (2 * Math.PI)))
}

const raf = function() {
  updatePositions();
  updateVis();

  requestAnimationFrame(raf);
};
raf();




</script>
